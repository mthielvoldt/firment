
include(protocol/nanopb_py_env.cmake)

# TODO: this should probably be passed in from project somehow. 
set(PROJECT_PROTO ${PROJECT_SOURCE_DIR}/messages.proto)
set(PROBES_PROTO ${PROJECT_SOURCE_DIR}/probes.proto)
set(NANOPB_DIR ${CMAKE_CURRENT_SOURCE_DIR}/protocol/nanopb)
set(PLUGIN_DIR ${CMAKE_CURRENT_SOURCE_DIR}/protocol/pb-plugins)
set(PROTOC ${NANOPB_DIR}/generator/protoc)

add_library(FirmentFW
  ${CMAKE_CURRENT_BINARY_DIR}/messages.pb.c # generated by protoc
  ${CMAKE_CURRENT_BINARY_DIR}/firment_msg.pb.c
  ${CMAKE_CURRENT_BINARY_DIR}/fmt_rx.pb.c   # generated by protoc-gen-firment plugin
  firmware/fmt_spi.c
  firmware/queue.c
  firmware/fmt_hardfault.c
  firmware/fmt_waveform.c
  firmware/fmt_log.c
  firmware/ghostProbe.c
  ${NANOPB_DIR}/pb_encode.c
  ${NANOPB_DIR}/pb_decode.c
  ${NANOPB_DIR}/pb_common.c
)

# Generate the version header for the firmware
configure_file(firmware/fmt_version.h.in version.h)

# Generate firment.proto with field size/length values filled in from 
# firment_config.json (in the project directory)
# ALERT:  using configure_file means you need to re-run cmake -B <build-dir>
# when either of the following change: 
# - firment_msg_config.json  (project file)
# - firment_msg.in.proto     (firment file)
# TODO: make this generation a custom command instead so build step handles it.
file(READ "${PROJECT_SOURCE_DIR}/firment_msg_config.json" PROTO_CONFIG_JSON)
string(JSON LOG_TEXT_MAX_SIZE      GET ${PROTO_CONFIG_JSON} log-text-max-size)
string(JSON PROBE_SIGNAL_MAX_COUNT GET ${PROTO_CONFIG_JSON} probe-signal-max-count)
message(STATUS "Log text max size: ${LOG_TEXT_MAX_SIZE}")
configure_file(protocol/firment_msg.in.proto firment_msg.proto)

# This generates messages from "messages.proto" in project root directory.
# TODO: make a target that creates the gen-venv. 
# TODO: move widgets to a more UI-oriented output location
# Note: in the command's last line, where the .proto files are listed, 
#   firment_msg.proto must *NOT* be prefixed with absolute path, or protoc won't 
#   recognize that it's the same file included by messages.proto, and everything 
#   defined in firment_msg.proto will appear to protoc as defined twice. 
add_custom_command(
  OUTPUT  messages.pb.c firment_msg.pb.c fmt_rx.pb.c
  COMMAND 
    . ${CMAKE_CURRENT_BINARY_DIR}/venv/bin/activate && 
    ${PROTOC}
      -I ${PROJECT_SOURCE_DIR}  # messages.proto, probes.proto
      -I ${CMAKE_CURRENT_BINARY_DIR} # firment_msg.proto
      --plugin=protoc-gen-firment=${PLUGIN_DIR}/gen-firment.py
      --plugin=protoc-gen-widgets=${PLUGIN_DIR}/gen-widgets.py
      --firment_out=${CMAKE_CURRENT_BINARY_DIR}
      --widgets_out=${CMAKE_CURRENT_BINARY_DIR}
      --nanopb_out=${CMAKE_CURRENT_BINARY_DIR}
      ${PROJECT_PROTO} firment_msg.proto ${PROBES_PROTO} 
  DEPENDS
    ${VIRTUAL_ENV_DIR}
    ${PROBES_PROTO}
    ${PROJECT_PROTO}
    ${CMAKE_CURRENT_BINARY_DIR}/firment_msg.proto
)

target_link_libraries(FirmentFW
  PRIVATE
    MCUPort
)

target_include_directories(FirmentFW 
  PRIVATE
    ${PROJECT_SOURCE_DIR}/firmware # ISR_Config.h used by fmt_spi
    ${CMAKE_CURRENT_BINARY_DIR} #  fmt_rx_pb.c > fmt_spi.h > messages.pb.h
  PUBLIC
    firmware/lib/CMSIS-6.1.0/Driver/Include # fmt_rx_pb.c > fmt_spi.h > Driver_SPI.h
    protocol/nanopb # fmt_spi.h > messages.pb.h > pb.h
    firmware # fmt_rx.h used by fmt_rx.pb.c
  INTERFACE     # Consuming targets need these headers, but this library doesn't
    ${CMAKE_CURRENT_BINARY_DIR}
)